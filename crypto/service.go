package crypto

import "fmt"

// CryptoService — основная структура, предоставляющая все криптографические операции.
// Она инкапсулирует набор криптографических ключей и гарантирует,
// что все операции (шифрование, хеширование и т.д.) выполняются
// с правильными ключами для каждого типа данных.
//
// Принципы проектирования:
//   - Иммутабельность: после создания ключи нельзя изменить
//   - Безопасность: все ключи проверяются на этапе инициализации
//   - Изоляция: каждый тип данных (email, phone и т.д.) использует свой ключ
type CryptoService struct {
	// keys — приватное поле, содержащее карту "тип данных → 32-байтный ключ".
	// Доступ к ключам возможен только через методы структуры.
	keys KeyMap
}

// NewCryptoService создаёт новый экземпляр CryptoService с заданными ключами.
//
// Параметры:
//   - keys: карта, где ключ — строковое имя типа данных (например, "USER_EMAIL"),
//           а значение — 32-байтный криптографический ключ.
//
// Требования к ключам:
//   - Каждый ключ ДОЛЖЕН быть ровно 32 байта (256 бит).
//     Это необходимо для AES-256 и обеспечения безопасности хеш-функций.
//
// Возвращает:
//   - *CryptoService: указатель на готовый к использованию сервис
//   - error: если хотя бы один ключ не соответствует требованиям
//
// Особенности:
//   - Валидация происходит один раз при создании — дальнейшие операции не проверяют ключи
//   - Это повышает производительность и гарантирует, что сервис всегда в валидном состоянии
func NewCryptoService(keys KeyMap) (*CryptoService, error) {
	// Проходим по всем переданным ключам
	for name, key := range keys {
		// Проверяем, что длина ключа строго равна 32 байтам
		if len(key) != 32 {
			// Возвращаем понятную ошибку с обёрткой (wrapping),
			// чтобы вызывающий код мог использовать errors.Is(err, ErrInvalidKeySize)
			return nil, fmt.Errorf("%w: %q (got %d bytes)", ErrInvalidKeySize, name, len(key))
		}
	}
	// Если все ключи валидны — создаём и возвращаем новый сервис
	return &CryptoService{keys: keys}, nil
}

// GetKey возвращает криптографический ключ для указанного типа данных.
//
// Параметры:
//   - dataType: строковое имя типа данных (например, "USER_EMAIL")
//
// Возвращает:
//   - []byte: 32-байтный ключ (если найден)
//   - bool: true, если ключ существует; false — если нет
//
// Назначение:
//   - Позволяет расширять функциональность за пределами базового API модуля
//   - Например, если тебе понадобится реализовать кастомную операцию,
//     требующую прямого доступа к ключу
//   - Не рекомендуется использовать напрямую в обычном коде — лучше вызывать
//     готовые методы вроде Encrypt(), HashData() и т.д.
//
// Безопасность:
//   - Возвращается копия среза? Нет — в Go срезы являются "окном" в массив.
//     Но так как ключи иммутабельны (никто не меняет cs.keys после создания),
//     это безопасно.
func (cs *CryptoService) GetKey(dataType string) ([]byte, bool) {
	key, ok := cs.keys[dataType]
	return key, ok
}
